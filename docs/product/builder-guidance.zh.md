# Builder 向导

Builder向导通过设计一个有趣、功能完整且具有故事剧情的游戏项目，采用各种交互式、跟随式引导，旨在引导零编程基础的新用户快速上手Builder产品和Go+语言。用户完成本向导后，可以得到一个小游戏，能够在其上面自由发挥并发布到社区。

向导是一个入门级课程，教授Go+基本语法和快速上手Go+Builder。实际上，向导部分的产品设计具有很高的可扩展性，后续各种项目式、任务式课程均可采用此设计，即后续可引入多条故事线来丰富Builder的课程体系，我们后续也会开发一个用于开发Builder课程的效率工具，方便课程设计师打造精品课程。

Go+Builder使用文本编程开发游戏，和积木式编程有很大的不同，在整个向导过程中用户需要完成的绝大多数任务都是编写Go+代码，同时为了降低零编程基础用户上手的心智负担，Builder向导将观看视频+代码完形填空作为主要的引导方式。此外也会有UI引导帮助用户上手Builder的IDE。

## 基本概念

### 故事线

Builder向导引入故事线的概念，以一个故事剧情作为主线（牛小七救公主）贯穿整个向导，用户完成向导后可得到一个具有故事线的小游戏。

整个故事线被划分为多个关卡，在UI上体现为一个关卡list列表，采用地图的方式进行展示（城堡、勇士牛小七路线图等等）：

- 关卡之间有严格的先后顺序，前一关完成后才能解锁进入下一关。

- 完成指定关卡获得对应成就：这里的成就不是全局用户意义上成就，只是本向导下的成就，但依然要和用户绑定，比如“护花使者牛小七”、“英雄牛小七”、“屠龙战士牛小七”等

- 完成指定关卡获得指定限定素材（与素材库联动）：用户在完成向导的过程中，会涉及添加各种素材（精灵素材、声音素材、场景素材等），所需要使用的精美素材由我们提供，用户完成某个关卡后该关卡用到的素材免费送给用户，用户后续可以在自己的素材库中使用他们，添加进自己的Builder项目中。

整个故事线只会在用户首次进入第一关时为用户创建一个Project（假设叫它A，基本信息预设提供），不同的故事线之间是独立的，一个故事线对应一个A，这个 A 的 Name、Description等基本信息使用对应故事线的信息来构造。用户后续进入关卡(包括已完成的关卡和未完成的关卡)打开的Project就是A。

是否创建Project A，根据该故事线的状态来定（故事线状态为“未开始”时，创建Project A）

用户完成最后一关时，再为用户创建一个Project（假设叫它B），B会包含整个故事线的完整Project内容，用户后续可自行在B上自由发挥。一个故事线对应一个B，允许多次完成同一个故事线（其实就是允许多次完成一个故事线的最后一关），但是仅在首次完成时创建Project B。

是否创建Project B，在最后一关的最后一个步骤完成后，根据故事线的状态来定（故事线状态为“已完成时”，不创建Project B，反之创建）

用户首次进入一个故事线的第一关时构造出的Project A 保存到云端，这个A不是用户账号下的一个普通 Project，与普通Project的区别在于A不展示在用户的项目列表中，但是B是用户账号下的一个普通 Project（即需要对现有的 Project 引入额外的信息，用于标记它是否“普通”。“普通”就展示在用户的项目列表中，“特殊”就不展示在用户的项目列表中）。

## 关卡

关卡是故事线的具体展现形式，是故事线中独立的操作任务，每个关卡之间有很强的先后逻辑顺序（保证故事线的连贯和编程知识的循序渐进、由浅入深）。

用户点击进入一个关卡会打开用户在该故事线下面的Project A（首次进入第一关就为用户创建Project A，用户在这个关卡中的所有操作（写代码和添加素材）都会自动保存到云端Project A中），然后弹出本关的关卡介绍，介绍本关需要完成的任务（以列表形式呈现本关各个节点任务的标题），用户点击“开始”后，开始依次进入每个节点任务，观看视频完成步骤，即：

- 一个关卡有多个节点任务，节点任务之间有严格的先后顺序，用户只有完成该节点任务才可进入下一节点任务

- 一个节点任务有一个视频，观看完视频才可进行步骤的完成

- 一个节点任务有一个或多个步骤，用户完成所有步骤后即可完成该节点任务。当所有节点任务完成，本关通关解锁下一关。

用户观看的视频不允许拖拽只允许暂停，且当用户在观看视频的过程中，应该禁止用户对当前Builder项目的更改，只有用户进入步骤时，才能在我们开放的区域对Builder项目进行更改。用户也可以跳过当前观看的视频，直接来到第一个步骤。

一个关卡只提供本关卡所需的spx API：

- 这样做的考虑：

  - 简化实现，取消使用UI高亮引导用户点击API

  - 可以将整个spx API区域和代码编辑区域开放给用户，用户操作更接近实际开发

  - 只提供需要的，降低用户查询所需API的心智负担

  - 编码式步骤中具体会用到哪个API，该步骤下的content会明确指出

## 步骤

步骤是用户完成一次操作的最小单位，分为Coding步骤和跟随式步骤（后续也可以扩展其他步骤）。

### Coding步骤

开放代码编辑区域与spx API区域让用户写代码，需要定位代码编辑区域的位置并将其高亮展示（其他区域蒙层禁止用户操作）。为了尽可能降低用户上手难度，采用“完形填空”的方式。

完形填空：Coding步骤需要存储一个步骤初始快照和一个步骤结束快照（均仅为Project的Game（游戏内容））：

- 步骤结束快照中会有部分代码是答案代码，即用户通过本步骤需要添加的代码。

- 步骤初始快照中对应答案代码的部分是挖了空的待补全代码（模板代码）
该步骤开始时，Builder会重新加载步骤初始快照以替换编辑器当前的Game游戏内容，用户在提供的模板代码上补全并通过检测即可完成该步骤。

Coding步骤会提供如下交互选项：

- 代码检测：用户点击代码检测后，会将编辑器当前的快照和步骤结束快照进行比对（格式化后字符串比对）。通过比对后就算通过了检测。如果没有通过比对，就调用后端接口借助大模型进行比对。

- 查看答案：查看答案代码

### 跟随式步骤

主要借助UI引导的方式，引导用户跟随式操作。

跟随式步骤可能出现的场景：

- 引导用户切换到指定精灵或舞台的代码编辑

- 引导用户操作舞台（添加背景、添加控件）

- 引导用户添加声音

- 引导用户添加精灵

- 引导用户图形化操作精灵

- 引导用户添加精灵动画（造型组动画和骨骼动画）

- 引导用户运行项目

UI引导在引导中通过多种手段引导用户完成跟随式操作：

- UI高亮

- 箭头指引

- 图文呈现

- 精灵素材图

- 蒙层（限制用户操作）

跟随式步骤的粒度：在一个添加精灵的操作中，实际上应该至少划分为四个跟随式步骤：

- 引导用户点击添加精灵按钮（+号）

- 引导用户点击“从素材库选择”

- 引导用户点击指定精灵素材

- 引导用户点击确认按钮

根据上述的“粒度”可以发现，有些跟随式步骤是会改变Builder项目状态的，而有些是不会改变的。而对于会改变Builder项目状态的那些跟随式步骤，需要对改变后的状态进行检测以判断用户是否可以通过该步骤，即需要存储一个步骤结束快照，用于快照比对。

### 快照比对

用户在编码式步骤中完成代码的完形填空后点击“检测代码”、完成改变Builder项目状态的跟随式步骤后，需要触发快照比对以检测用户是否能够通过该步骤。这种快照比对的实现有多种：

- 对快照的所有或者部分内容进行字符串比对

- 对快照的所有或者部分内容进行正则比对

- 借助大模型完成比对

### 步骤基本信息结构

1. title：步骤名称
2. index：步骤次序
3. description：步骤描述
4. tip：互动提示（需要条件触发）
5. duration：用户当前步骤卡顿距离给提示的时长，也就是tip互动提示的触发时机，如5秒
6. feedback：用户完成检测后的反馈信息
7. target：目标元素的id或者class字符串，用于定位本引导步骤的目标元素，目标元素高亮，其他部分蒙层禁止用户操作
8. content：步骤的描述内容
9. placement：步骤提示框放置在目标元素的方位[”left”, “top”, “right”, “bottom”]
10. type: 步骤类型（Coding步骤、跟随式步骤）
11. isCheck：该步骤是否涉及快照比对
12. startSnapshot：步骤初始快照（所有步骤都有，并暂定来到一个步骤Builder项目都会加载这个快照。）
  a. 可能的问题：加载快照可能会和IDE信息冲突
13. endSnapshot：步骤结束快照（只有isCheck为true才有这个）

编码式步骤特有信息结构

1. path：编码文件路径，用于描述编码文件在当前快照中的路径，例如需要在Sprite A中进行编码，则为”sprite/A”
2. tokenMask：完形填空挖空位置内容
  - tokenStartPos：当前空白起始位置
  - tokenEndPos：当前空白结束位置