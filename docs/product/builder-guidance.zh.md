# Builder 向导

Builder 向导通过设计一个有趣、功能完整且具有故事剧情的游戏项目，采用各种交互式、跟随式引导，旨在引导零编程基础的新用户快速上手 Builder 产品和 Go+语言。用户完成本向导后，可以得到一个小游戏，能够在其上面自由发挥并发布到社区。

向导是一个入门级课程，教授 Go+基本语法和快速上手 Go+Builder。实际上，向导部分的产品设计具有很高的可扩展性，后续各种项目式、任务式课程均可采用此设计，即后续可引入多条故事线来丰富 Builder 的课程体系，我们后续也会开发一个用于开发 Builder 课程的效率工具，方便课程设计师打造精品课程。

Go+Builder 使用文本编程开发游戏，和积木式编程有很大的不同，在整个向导过程中用户需要完成的绝大多数任务都是编写 Go+代码，同时为了降低零编程基础用户上手的心智负担，Builder 向导将观看视频+代码完形填空作为主要的引导方式。此外也会有 UI 引导帮助用户上手 Builder 的 IDE。

## 基本概念

### 故事线

Builder 向导引入故事线的概念，以一个故事剧情作为主线（牛小七救公主）贯穿整个向导，用户完成向导后可得到一个具有故事线的小游戏。
整个故事线被划分为多个关卡，在 UI 上体现为一个关卡 list 列表，采用地图的方式进行展示（城堡、勇士牛小七路线图等等）：

- 关卡之间有严格的先后顺序，前一关完成后才能解锁进入下一关。
- 完成指定关卡获得对应成就：这里的成就不是全局用户意义上成就，只是本向导下的成就，但依然要和用户绑定，比如“护花使者牛小七”、“英雄牛小七”、“屠龙战士牛小七”等
- 完成指定关卡获得指定限定素材（与素材库联动）：用户在完成向导的过程中，会涉及添加各种素材（精灵素材、声音素材、场景素材等），所需要使用的精美素材由我们提供，用户完成某个关卡后该关卡用到的素材免费送给用户，用户后续可以在自己的素材库中使用他们，添加进自己的 Builder 项目中。
- 在地图上，一个关卡应该具有的信息：
  - title: 本关标题
  - image: 本关封面

### 关卡

关卡是故事线的具体展现形式，是故事线中独立的操作任务，每个关卡之间有很强的先后逻辑顺序（保证故事线的连贯和编程知识的循序渐进、由浅入深）。

每个关卡都有一个我们预设提供的关卡初始快照（实际上就是一个 Builder 项目，存储体现为一个很轻量的 JSON），用户点击进入一个关卡，打开的 Builder 项目是这个快照的拷贝（而不是引用），用户在这个关卡中的所有操作（写代码和添加素材）都是对这个拷贝的更改。如果用户点击进入一个已完成或者只完成一半的关卡，打开的也是这个关卡初始快照的拷贝，而不是之前用户在本关操作后退出时的那个快照。

一个关卡开始应有一个介绍，介绍本关需要完成的任务并向用户呈现运行效果（可以通过一个视频、 图片，或仅仅是文字），然后用户开始依次进入每个节点任务，观看视频完成步骤，即：

- 一个关卡有多个节点任务，节点任务之间有严格的先后顺序，用户只有完成该节点任务才可进入下一节点任务
- 一个节点任务有一个视频，观看完视频才可进行步骤的完成
- 一个节点任务有一个或多个步骤，用户完成所有步骤后即可完成该节点任务。当所有节点任务完成，本关通关解锁下一关。

用户观看的视频不允许拖拽只允许暂停，且当用户在观看视频的过程中，应该禁止用户对当前 Builder 项目的更改，只有用户进入步骤时，才能在我们开放的区域对 Builder 项目进行更改。用户也可以跳过当前观看的视频，直接来到第一个步骤。

一个关卡只提供本关卡所需的 spx API：

- 这样做的考虑：
  - 简化实现，取消使用 UI 高亮引导用户点击 API
  - 可以将整个 spx API 区域和代码编辑区域开放给用户，用户操作更接近实际开发
  - 只提供需要的，降低用户查询所需 API 的心智负担
  - 编码式步骤中具体会用到哪个 API，该步骤下的 content 会明确指出

### 步骤

步骤是用户完成一次操作的最小单位，分为 Coding 步骤和跟随式步骤（后续也可以扩展其他步骤）。

#### Coding 步骤

开放代码编辑区域与 spx API 区域让用户写代码，需要定位代码编辑区域的位置并将其高亮展示（其他区域蒙层禁止用户操作）。为了尽可能降低用户上手难度，采用“完形填空”的方式。

完形填空：Coding 步骤需要存储一个步骤初始快照，这个快照中会有部分代码是挖了空的待补全代码（模板代码），需要用户在该步骤中补全。即该步骤开始时，Builder 会重新加载这个快照，用户在提供的模板代码上补全并通过检测即可完成该步骤。Coding 步骤会提供如下交互选项：

- 代码检测：Coding 步骤还会存储一个步骤结束快照，用户点击代码检测后，会将当前的快照和这个步骤结束快照进行比对。通过比对后就算通过了检测。
- 查看答案：查看答案代码和解析

#### 跟随式步骤

主要借助 UI 引导的方式，引导用户跟随式操作。

跟随式步骤可能出现的场景：

- 引导用户切换到指定精灵或舞台的代码编辑
- 引导用户操作舞台（添加背景、添加控件）
- 引导用户添加声音
- 引导用户添加精灵
- 引导用户图形化操作精灵
- 引导用户添加精灵动画（造型组动画和骨骼动画）
- 引导用户运行项目

UI 引导在引导中通过多种手段引导用户完成跟随式操作：

- UI 高亮
- 箭头指引
- 图文呈现
- 精灵素材图
- 蒙层（限制用户操作）

跟随式步骤的粒度：在一个添加精灵的操作中，实际上应该至少划分为四个跟随式步骤：

- 引导用户点击添加精灵按钮（+号）
- 引导用户点击“从素材库选择”
- 引导用户点击指定精灵素材
- 引导用户点击确认按钮

根据上述的“粒度”可以发现，有些跟随式步骤是会改变 Builder 项目状态的，而有些是不会改变的。而对于会改变 Builder 项目状态的那些跟随式步骤，需要对改变后的状态进行检测以判断用户是否可以通过该步骤，即需要存储一个步骤结束快照，用于快照比对。

#### 快照比对

用户在编码式步骤中完成代码的完形填空后点击“检测代码”、完成改变 Builder 项目状态的跟随式步骤后，需要触发快照比对以检测用户是否能够通过该步骤。这种快照比对的实现有多种：

- 对快照的所有或者部分内容进行字符串比对
- 对快照的所有或者部分内容进行正则比对
- 借助大模型完成比对

#### 步骤基本信息结构

1. title：步骤名称
2. index：步骤次序
3. description：步骤描述
4. tip：互动提示（需要条件触发）
5. duration：用户当前步骤卡顿距离给提示的时长，也就是 tip 互动提示的触发时机，如 5 秒
6. feedback：用户完成检测后的反馈信息
7. target：目标元素的 id 或者 class 字符串，用于定位本引导步骤的目标元素，目标元素高亮，其他部分蒙层禁止用户操作
8. content：步骤的描述内容
9. placement：步骤提示框放置在目标元素的方位[”left”, “top”, “right”, “bottom”]
10. type: 步骤类型（Coding 步骤、跟随式步骤）
11. isCheck：该步骤是否涉及快照比对
12. startSnapshot：步骤初始快照（所有步骤都有，并暂定来到一个步骤 Builder 项目都会加载这个快照。）
    a. 可能的问题：加载快照可能会和 IDE 信息冲突
13. endSnapshot：步骤结束快照（只有 isCheck 为 true 才有这个）

#### 编码式步骤特有信息结构

1. path：编码文件路径，用于描述编码文件在当前快照中的路径，例如需要在 Sprite A 中进行编码，则为”sprite/A”
2. tokenMask：完形填空挖空位置内容
   a. tokenStartPos：当前空白起始位置
   b. tokenEndPos：当前空白结束位置
