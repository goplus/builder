## 第七章：条件 - 根据情况做决定

到目前为止，我们的程序都像一条笔直的路：
- 从头到尾执行所有代码
- 无论什么情况，都做相同的事情
- 不能根据情况改变行为

但在真实世界中，我们经常需要**做选择**：
- 如果下雨，就带伞；如果不下雨，就不带
- 如果饿了，就吃饭；如果不饿，就不吃
- 如果作业做完了，就去玩；如果没做完，就继续做

在游戏中也是一样：
- 如果碰到敌人，就逃跑
- 如果生命值低，就补血
- 如果萝卜成熟了，就去采摘
- 如果得分够高，就进入下一关

这种"根据情况做决定"的能力，就是**条件判断**（Conditional Statement）！条件判断让程序变得智能，能够应对不同的情况。

### 7.1 简单条件

#### 学习目标

这一节，我们将学习编程中最重要的概念之一：**if 语句**（条件语句）。你将学会：
- 如何根据条件执行代码
- 理解"如果...那么..."的逻辑
- 使用条件判断让程序更智能

掌握条件判断后，你的程序将能够"思考"和"决策"！

#### 新的挑战：只采摘成熟的萝卜

看看这次的场景，地里有一个萝卜1，但它可能成熟，也可能还没成熟。我们需要让 Kiko：
- **如果**萝卜成熟了，**就**去采摘
- **如果**萝卜没成熟，**就**不去采摘（等待或做其他事）

这就需要条件判断！程序要能够"检查"萝卜的状态，然后"决定"是否去采摘。

![Course-31](./assets/条件-1.png)
> 课程地址：https://x.qiniu.com/editor/curator/Coding-Course-31/sprites/Kiko/code

**完整代码：**
```go
onStart => {
    if 萝卜1.IsMature() {
        turnTo 萝卜1
        stepTo 萝卜1
    }
}
```

#### 代码详解

**认识 if 语句**

```go
if 条件 {
    代码块
}
```

这是**条件语句**的基本语法：
- `if`：关键字，表示"如果"
- `条件`：一个返回真/假的表达式
- `{}`：代码块，当条件为真时执行

**完整语句分析**

```go
if 萝卜1.IsMature() {
    turnTo 萝卜1
    stepTo 萝卜1
}
```

让我们拆解这段代码：

| 部分 | 作用 | 说明 |
|------|------|------|
| `if` | 条件关键字 | 表示"如果" |
| `萝卜1.IsMature()` | 条件表达式 | 检查萝卜1是否成熟 |
| `{}` | 代码块 | 条件为真时执行的代码 |

**IsMature 函数**

```go
萝卜1.IsMature()
```

这是一个**对象方法**（Object Method）：
- `萝卜1`：对象名
- `.`：访问符号
- `IsMature()`：方法名（Is Mature = 是否成熟）
- `()`：函数调用的括号（必须有）
- **返回值**：`true`（成熟）或 `false`（未成熟）

**注意**：`IsMature` 是一个**函数**（有括号），不是属性：
- 属性：`萝卜1.mature`（直接访问值）
- 方法：`萝卜1.IsMature()`（调用函数获取值）

**执行流程**

```go
if 萝卜1.IsMature() {
    turnTo 萝卜1
    stepTo 萝卜1
}
```

**情况 1：萝卜已成熟**

```
1. 调用 萝卜1.IsMature()
2. 返回 true（成熟了）
3. 条件为真，执行代码块
4. 执行 turnTo 萝卜1
5. 执行 stepTo 萝卜1
6. Kiko 走到萝卜1并采摘
```

**情况 2：萝卜未成熟**

```
1. 调用 萝卜1.IsMature()
2. 返回 false（还没成熟）
3. 条件为假，跳过代码块
4. 不执行 turnTo 和 stepTo
5. Kiko 保持不动
```

**流程图**

```
开始
  ↓
检查：萝卜1.IsMature() == true？
  ├─ 是 → 执行代码块 → turnTo 萝卜1 → stepTo 萝卜1
  │                      ↓
  └─ 否 → 跳过代码块 ────┘
  ↓
继续执行后面的代码
```

#### if 语句的特点

**1. 条件必须返回布尔值**

条件表达式的结果必须是 `true` 或 `false`：

```go
// ✓ 正确：返回布尔值
if 萝卜1.IsMature() { }          // 函数返回 true/false
if xpos > 100 { }                 // 比较返回 true/false
if 萝卜1.mature { }               // 属性是布尔值

// ✗ 错误：不返回布尔值
if 萝卜1 { }                      // 对象不是布尔值
if 100 { }                        // 数字不是布尔值
```

**2. 代码块可能不执行**

这是 `if` 和之前学的循环的重要区别：

```go
// repeat：总是执行
repeat 3, => {
    step 10  // 一定会执行3次
}

// if：可能不执行
if 萝卜1.IsMature() {
    step 10  // 可能执行，也可能不执行
}
```

**3. 可以有多行代码**

代码块内可以有任意多行代码：

```go
if 萝卜1.IsMature() {
    turnTo 萝卜1       // 第1行
    stepTo 萝卜1       // 第2行
    turn Right         // 第3行
    step 50            // 第4行
    // 可以有更多行...
}
```

所有这些代码要么全部执行（条件为真），要么全部不执行（条件为假）。

#### 条件表达式的类型

**1. 函数调用（返回布尔值）**

```go
if 萝卜1.IsMature() {  // 调用函数
    turnTo 萝卜1
}
```

**2. 比较运算**

```go
if xpos > 100 {        // 比较运算
    step 50
}

if ypos < 50 {
    step -20
}
```

**3. 布尔属性**

```go
if 萝卜1.mature {      // 直接使用布尔属性（如果有）
    turnTo 萝卜1
}
```

**4. 布尔变量**

```go
var isReady = true

if isReady {           // 直接使用布尔变量
    step 100
}
```

#### 本节重点

| 概念 | 说明 | 示例 |
|------|------|------|
| `if` 语句 | 根据条件执行代码 | `if 条件 { 代码 }` |
| 条件表达式 | 返回 true/false 的表达式 | `萝卜1.IsMature()` |
| 代码块 | 条件为真时执行的代码 | `{ turnTo 萝卜1; stepTo 萝卜1 }` |
| 对象方法 | 对象的函数 | `IsMature()` |
| 选择执行 | 代码可能执行或跳过 | 取决于条件 |

#### 恭喜你！

你现在已经掌握了：
- 使用 `if` 语句进行条件判断
- 理解条件表达式和布尔值
- 调用对象方法检查状态
- 让程序根据情况做决定
- 理解"守卫模式"的思想

条件判断让你的程序拥有了"智能"！

---

**下一节预告**：我们已经学会了单独使用条件判断，但如果要在循环中使用条件呢？比如，遍历所有萝卜，但只采摘成熟的？下一节将学习**条件与循环的结合**，创造更强大的程序逻辑！

### 7.2 条件与循环结合

#### 学习目标

在上一节中，我们学会了使用 `if` 语句进行条件判断。但那只是针对单个对象。在真实的游戏中，我们经常需要：
- 检查**多个**对象
- 对每个对象做**不同的处理**
- 只处理**符合条件**的对象

比如：
- 遍历所有萝卜，只采摘成熟的
- 检查所有敌人，只攻击靠近的
- 查看所有宝石，只收集特定颜色的

这就需要把**循环**和**条件判断**结合起来！这一节，我们将学习这个强大的组合技巧。

#### 新的挑战：选择性采摘

看看这次的场景，地里有三个萝卜：萝卜1、萝卜2、萝卜3。但它们的成熟状态可能不同：
- 萝卜1：可能成熟，可能没成熟
- 萝卜2：可能成熟，可能没成熟
- 萝卜3：可能成熟，可能没成熟

我们需要让 Kiko：
1. 检查每一个萝卜
2. 如果成熟了，就去采摘
3. 如果没成熟，就跳过

这需要**遍历所有萝卜**（循环），并且**检查每个萝卜的状态**（条件）！

![Course-32](./assets/条件-2.png)
> 课程地址：https://x.qiniu.com/editor/curator/Coding-Course-32/sprites/Kiko/code

**完整代码：**
```go
onStart => {
    var radishs []Radish = [萝卜1, 萝卜2, 萝卜3]
    for v in radishs {
        if v.IsMature() {
            turnTo v
            stepTo v
        }
    }
}
```

#### 代码详解

**数组类型声明**

```go
var radishs []Radish = [萝卜1, 萝卜2, 萝卜3]
```

这次我们看到了新的语法：**带类型的数组定义**

| 部分 | 作用 | 说明 |
|------|------|------|
| `var radishs` | 变量名 | 数组变量 |
| `[]Radish` | 数组类型 | Radish 对象的数组 |
| `=` | 赋值 | 赋值符号 |
| `[萝卜1, 萝卜2, 萝卜3]` | 数组值 | 三个萝卜对象 |

**为什么要指定类型？**

```go
// 之前：字符串数组（对象名）
var radishs = ["萝卜1", "萝卜2", "萝卜3"]

// 现在：对象数组（对象本身）
var radishs []Radish = [萝卜1, 萝卜2, 萝卜3]
```

区别：
- **字符串数组**：存储对象的名字（字符串）
- **对象数组**：存储对象本身（可以调用对象的方法）

**对象数组的优势**：
- 可以直接调用对象的方法：`v.IsMature()`
- 可以访问对象的属性：`v.xpos`, `v.mature`
- 不需要通过名字字符串来访问对象

**循环与条件的嵌套**

```go
for v in radishs {           // 外层：循环
    if v.IsMature() {        // 内层：条件
        turnTo v
        stepTo v
    }
}
```

这是**嵌套结构**（Nested Structure）：
- `if` 语句在 `for` 循环内部
- 每次循环都会执行 `if` 判断
- 只有条件为真时才执行 `turnTo` 和 `stepTo`

**执行流程详解**

让我们详细看看代码是如何执行的：

**第 1 次循环**：
```
1. v = 萝卜1（第1个元素）
2. 检查：萝卜1.IsMature() == true？
   ├─ 是 → 执行 turnTo 萝卜1, stepTo 萝卜1
   └─ 否 → 跳过，不采摘
3. 继续下一次循环
```

**第 2 次循环**：
```
1. v = 萝卜2（第2个元素）
2. 检查：萝卜2.IsMature() == true？
   ├─ 是 → 执行 turnTo 萝卜2, stepTo 萝卜2
   └─ 否 → 跳过，不采摘
3. 继续下一次循环
```

**第 3 次循环**：
```
1. v = 萝卜3（第3个元素）
2. 检查：萝卜3.IsMature() == true？
   ├─ 是 → 执行 turnTo 萝卜3, stepTo 萝卜3
   └─ 否 → 跳过，不采摘
3. 循环结束（没有更多元素）
```

**可能的执行结果**

根据萝卜的成熟状态，有不同的结果：

**情况 1：全部成熟**
```
萝卜1 成熟 → 采摘萝卜1
萝卜2 成熟 → 采摘萝卜2
萝卜3 成熟 → 采摘萝卜3
结果：采摘了3个萝卜
```

**情况 2：部分成熟**
```
萝卜1 成熟 → 采摘萝卜1
萝卜2 未成熟 → 跳过
萝卜3 成熟 → 采摘萝卜3
结果：采摘了2个萝卜
```

**情况 3：全部未成熟**
```
萝卜1 未成熟 → 跳过
萝卜2 未成熟 → 跳过
萝卜3 未成熟 → 跳过
结果：一个都没采摘
```

#### 本节重点

| 概念 | 说明 | 示例 |
|------|------|------|
| 循环+条件 | 在循环中使用条件判断 | `for v in arr { if ... {} }` |
| 对象数组 | 存储对象的数组 | `[]Radish` |
| 嵌套结构 | 一个结构包含另一个结构 | 条件在循环内 |
| 过滤模式 | 筛选符合条件的元素 | 只处理成熟的萝卜 |
| 选择性处理 | 不是处理所有元素 | 跳过不符合条件的 |

#### 恭喜你！

你现在已经掌握了：
- 创建对象数组
- 在循环中使用条件判断
- 理解嵌套结构
- 实现过滤和选择性处理
- 编写更智能的程序逻辑

循环与条件的结合让你的程序更加强大和智能！

---

**下一节预告**：我们已经学会了 `if` 语句（如果...那么...），但有时候我们还需要"否则"（else）的逻辑。比如：如果萝卜成熟就采摘，**否则**就等待。下一节将学习 `if...else` 语句，让条件判断更完整！

#### 7.2.1 练习：条件与循环结合1

练习条件语句与循环的组合使用：

> 课程地址：https://x.qiniu.com/editor/curator/Coding-Course-33/sprites/Kiko/code

**练习内容：**
掌握在循环中使用条件判断控制程序流程。

#### 7.2.2 练习：条件与循环结合2

进阶条件与循环结合练习：

> 课程地址：https://x.qiniu.com/editor/curator/Coding-Course-34/sprites/Kiko/code

**练习内容：**
在更复杂的场景中运用条件与循环结合的技巧。

### 7.3 复杂条件处理

#### 学习目标

在上一节中，我们学会了 `if` 语句：如果条件满足，就执行某些代码。但有时候，我们还需要处理"否则"的情况：
- 如果萝卜成熟了，就采摘；**否则**就等待
- 如果门开了，就通过；**否则**就等门开
- 如果有钥匙，就开门；**否则**就去找钥匙

这种"如果...否则..."的逻辑，需要用到 `if...else` 语句。这一节，我们将学习更完整的条件判断，并通过一个实际的游戏场景来应用它。

#### 新的挑战：照顾萝卜直到成熟

看看这次的场景，这是一个完整的"种植游戏"流程：

**第一阶段：检查和照顾**
- 遍历所有萝卜
- **如果**萝卜成熟了，**就**去采摘
- **否则**（萝卜没成熟），**就**给它浇水

**第二阶段：等待和收获**
- 等待所有萝卜成熟
- 依次收获所有萝卜

这个任务需要用到我们学过的几乎所有知识：数组、循环、条件、函数、等待！

![Course-35](./assets/条件-3.png)
> 课程地址：https://x.qiniu.com/editor/curator/Coding-Course-35/sprites/Kiko/code

**完整代码：**
```go
onStart => {
    var radishs []Radish = [萝卜1, 萝卜2, 萝卜3]
    
    // 第一阶段：检查和照顾
    for v in radishs {
        if v.IsMature() {
            turnTo v
            stepTo v
        } else {
            turnTo v
            step distanceTo(v)-20
            v.Water()
            animateAndWait "浇花"
        }
    }

    // 第二阶段：等待和收获
    for v in radishs {
        waitUntil v.IsMature()
        turnTo v
        stepTo v
    }
}
```

#### 代码详解

**认识 if...else 语句**

```go
if 条件 {
    代码块1
} else {
    代码块2
}
```

这是**完整的条件语句**：
- `if 条件`：如果条件为真
- `代码块1`：执行这些代码
- `else`：否则（条件为假时）
- `代码块2`：执行这些代码

**执行规则**：
- 条件为真：执行代码块1，**跳过**代码块2
- 条件为假：**跳过**代码块1，执行代码块2
- **两个代码块只会执行一个**，不会都执行

**第一阶段：检查和照顾**

```go
for v in radishs {
    if v.IsMature() {
        // 分支1：萝卜成熟了
        turnTo v
        stepTo v
    } else {
        // 分支2：萝卜没成熟
        turnTo v
        step distanceTo(v)-20
        v.Water()
        animateAndWait "浇花"
    }
}
```

**if 分支（萝卜成熟）**：
```go
turnTo v     // 转向萝卜
stepTo v     // 走到萝卜（采摘）
```
- 简单直接
- 采摘成熟的萝卜

**else 分支（萝卜未成熟）**：
```go
turnTo v                      // 转向萝卜
step distanceTo(v)-20         // 走到萝卜附近（距离20步）
v.Water()                     // 给萝卜浇水
animateAndWait "浇花"         // 播放浇花动画
```
- 更复杂的操作
- 照顾未成熟的萝卜

**为什么要减 20？**

```go
step distanceTo(v)-20
```

这行代码很巧妙：
- `distanceTo(v)`：计算到萝卜的距离（比如 100）
- `-20`：减去 20
- 结果：走到距离萝卜 20 步的位置（走 80 步）

**为什么不直接走到萝卜那里？**
- 浇水需要保持一定距离
- 太近可能会踩到萝卜
- 保持 20 步距离刚好适合浇水

**Water 方法**

```go
v.Water()
```

这是调用萝卜对象的**浇水方法**：
- `v`：当前的萝卜对象
- `.Water()`：浇水方法
- 括号必须有（这是函数调用）

执行后，萝卜会被浇水，可能会加快成熟。

**animateAndWait 命令**

```go
animateAndWait "浇花"
```

这是一个新命令：
- `animateAndWait`：播放动画并等待
- `"浇花"`：动画的名称
- 效果：播放浇花动画，等动画播放完才继续

这让游戏更生动！

**第二阶段：等待和收获**

```go
for v in radishs {
    waitUntil v.IsMature()  // 等待萝卜成熟
    turnTo v
    stepTo v
}
```

**为什么需要第二阶段？**

第一阶段后：
- 成熟的萝卜已经被采摘
- 未成熟的萝卜被浇了水，但还没成熟

第二阶段：
- 等待那些被浇水的萝卜成熟
- 然后采摘它们

这样确保**所有萝卜最终都被采摘**。

#### if...else 的特点

**1. 互斥执行**

两个分支**只会执行一个**：

```go
if 条件 {
    // 分支A
} else {
    // 分支B
}
// 要么执行A，要么执行B，不会都执行
```

**2. 覆盖所有情况**

`if...else` 覆盖了所有可能：
- 条件为真：执行 if 分支
- 条件为假：执行 else 分支
- 没有第三种情况

**3. else 是可选的**

```go
// 只有 if（可以）
if 条件 {
    // 代码
}

// if + else（也可以）
if 条件 {
    // 代码1
} else {
    // 代码2
}
```

#### 编程小知识

**什么是"分支"？**

**分支**（Branch）是程序执行路径的分叉：

```
        开始
          ↓
        条件？
       ╱    ╲
     是       否
    ╱          ╲
  分支A       分支B
    ╲          ╱
     ╲        ╱
        汇合
          ↓
        继续
```

程序根据条件选择不同的分支执行。

**决策表**

可以用表格理解 `if...else`：

| 条件 | 执行的代码 |
|------|-----------|
| true | if 分支 |
| false | else 分支 |

**完整性**

`if...else` 保证了**完整性**：
- 无论条件如何，总有代码执行
- 不会出现"什么都不做"的情况
- 处理了所有可能性

对比：

```go
// 只有 if：可能什么都不做
if 条件 {
    做某事
}
// 如果条件为假，什么都不做

// if...else：总会做点什么
if 条件 {
    做事情A
} else {
    做事情B
}
// 要么做A，要么做B
```

#### 本节重点

| 概念 | 说明 | 示例 |
|------|------|------|
| `if...else` | 完整的条件语句 | `if 条件 {} else {}` |
| 互斥执行 | 两个分支只执行一个 | 不会都执行 |
| else 分支 | 条件为假时执行 | 处理"否则"情况 |
| 对象方法 | 对象的函数 | `v.Water()` |
| 动画命令 | 播放动画 | `animateAndWait` |
| 两阶段处理 | 先处理，再等待收获 | 完整的游戏逻辑 |

#### 恭喜你！

你已经完成了第七章的所有内容！现在你掌握了：
- 使用 `if` 语句进行条件判断
- 使用 `if...else` 处理两种情况
- 在循环中使用条件判断
- 调用对象的方法
- 实现复杂的游戏逻辑（两阶段处理）
- 组合使用多个编程概念

条件判断让你的程序拥有了"智能"和"决策"能力！

#### 7.3.1 练习：复杂条件处理

练习复杂条件处理的综合应用：

> 课程地址：https://x.qiniu.com/editor/curator/Coding-Course-36/sprites/Kiko/code

**练习内容：**
掌握复杂条件判断和多层嵌套逻辑的处理技巧。
